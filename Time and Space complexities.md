The time complexity of generating all valid moves at any given board state is O(M), where M is the maximum number of moves associated with all pegs. Since each of the 15 positions has a fixed number of possible moves (no more than 5), and each move is checked using constant-time bitwise operations, the move validation in getValidMoves() runs in worst-case O(15 × 5) = O(75), which simplifies to O(1) due to the fixed board size. Applying a move takes constant time O(1) because it only involves a few bitwise operations. File I/O for loading and writing solutions has O(n) time complexity, where n is the number of board states saved (up to 32,768 for all possible board configurations).

The space complexity of the core game is also optimized. The board itself uses a single int (4 bytes) to represent 15 bits of state. The scoreMemo map stores mappings from each of the 2¹⁵ (32,768) possible board states to their best endgame score (1 integer each), leading to a total space use of approximately 32,768 × 8 bytes = 262,144 bytes ≈ 256 KB. The ALL_MOVES array is a 2D array of Move objects, with a fixed size of 15 × a few moves (totaling 36 moves). Even with object overhead, the space complexity remains small and constant due to the fixed board size and bounded data structures. The UI does not significantly affect space usage as it only manages rendering and selected state.
